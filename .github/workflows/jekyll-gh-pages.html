<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手势控制 3D 粒子系统</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            /* 确保页面填满视口 */
            width: 100vw; 
            height: 100vh;
        }

        #container { 
            position: absolute; 
            width: 100%; 
            height: 100%; 
            z-index: 2; /* 确保 3D 场景在最上层 */
        }
        
        /* 摄像头视频流和辅助画布 - 隐藏，只用于数据处理 */
        #video, #cameraCanvas { 
            display: none; 
        } 
        
        /* 全屏控制按钮样式 */
        #fullscreen-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            z-index: 100; /* 确保在最前面 */
            padding: 10px 15px;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            backdrop-filter: blur(5px);
        }

        /* 调整 dat.GUI 控件位置，使其不遮挡心形 */
        .dg.main {
            z-index: 100 !important;
        }
        .dg.main .close-button {
            background-color: #ff0088 !important;
        }
    </style>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>
    <div id="container"></div>
    <video id="video" playsinline></video>
    <canvas id="cameraCanvas"></canvas> 
    
    <button id="fullscreen-btn">全屏</button>

    <script>
        // -----------------------------------------------------------------------
        // 1. 全局配置和变量
        // -----------------------------------------------------------------------
        const container = document.getElementById('container');
        let scene, camera, renderer, particles;

        const config = {
            model: 'heart',
            particleColor: '#ff0088',
            numParticles: 40000,
            rotationSpeed: 0.005,
            spreadFactor: 1.0, // 由手势控制，1.0为默认大小
        };

        const models = {}; // 存储不同形状的点集
        let initialPositions = null; // 存储粒子群的初始位置
        let animationFrameId = null; // 存储动画帧 ID

        // -----------------------------------------------------------------------
        // 2. 核心 Three.js 初始化
        // -----------------------------------------------------------------------

        function init() {
            // 场景, 摄像头, 渲染器设置
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 150; 
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); // alpha: true 允许透明背景
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            loadModels();
            
            window.addEventListener('resize', onWindowResize, false);
            initGUI();
            initFullScreen();
            
            startHandTracking(); 
        }

        // -----------------------------------------------------------------------
        // 3. 模型和粒子生成 (实现多种形状)
        // -----------------------------------------------------------------------

        // 爱心点集 (Heart)
        function generateHeartPoints(count) {
            const points = [];
            const scale = 50; 
            for (let i = 0; i < count; i++) {
                const t = Math.random() * 2 * Math.PI; 
                const x = scale * 16 * Math.pow(Math.sin(t), 3);
                const y = -scale * (13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
                const z = (Math.random() - 0.5) * 20;
                points.push(x, y, z);
            }
            return new Float32Array(points);
        }

        // 星星点集 (Star / Sphere)
        function generateStarPoints(count) {
            const points = [];
            const radius = 80;
            for (let i = 0; i < count; i++) {
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(Math.random() * 2 - 1);
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.sin(phi) * Math.sin(theta);
                const z = radius * Math.cos(phi);
                points.push(x, y, z);
            }
            return new Float32Array(points);
        }
        
        // 烟花点集 (近似圆锥爆发)
        function generateFireworksPoints(count) {
            const points = [];
            const radius = 100;
            for (let i = 0; i < count; i++) {
                const r = Math.random() * radius;
                const theta = Math.random() * 2 * Math.PI;
                const phi = Math.acos(Math.random() * 2 - 1); // 球面随机分布
                
                // 模拟爆发后散开的形状
                const x = r * Math.sin(phi) * Math.cos(theta) * (0.5 + Math.random() * 0.5);
                const y = r * Math.sin(phi) * Math.sin(theta) * (0.5 + Math.random() * 0.5);
                const z = r * Math.cos(phi);
                
                points.push(x, y, z);
            }
            return new Float32Array(points);
        }

        function loadModels() {
            models['heart'] = generateHeartPoints(config.numParticles);
            models['star'] = generateStarPoints(config.numParticles);
            models['fireworks'] = generateFireworksPoints(config.numParticles);
            // TODO: 在这里添加 generateFlowerPoints, generateBuddhaPoints 等函数
            createParticles(models[config.model]);
        }

        function createParticles(pointArray) {
            if (particles) {
                scene.remove(particles);
                particles.geometry.dispose();
            }

            initialPositions = pointArray;
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(initialPositions.slice(), 3)); 
            
            const material = new THREE.PointsMaterial({
                size: 1.5, 
                color: new THREE.Color(config.particleColor),
                blending: THREE.AdditiveBlending, 
                transparent: true,
                sizeAttenuation: true 
            });
            
            particles = new THREE.Points(geometry, material);
            scene.add(particles);
        }

        function updateParticlePositions() {
            if (!particles || !initialPositions) return;

            const positions = particles.geometry.attributes.position.array;
            const factor = config.spreadFactor;

            // 应用缩放因子
            for (let i = 0; i < initialPositions.length; i += 3) {
                positions[i] = initialPositions[i] * factor;
                positions[i + 1] = initialPositions[i + 1] * factor;
                positions[i + 2] = initialPositions[i + 2] * factor;
            }

            particles.geometry.attributes.position.needsUpdate = true;
        }


        // -----------------------------------------------------------------------
        // 4. MediaPipe 摄像头追踪逻辑 (核心)
        // -----------------------------------------------------------------------

        const videoElement = document.getElementById('video');
        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 2, 
            modelComplexity: 1, 
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults); 

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length === 2) {
                const hand1 = results.multiHandLandmarks[0];
                const hand2 = results.multiHandLandmarks[1];

                // 使用手掌根部 (索引 0) 计算距离
                const point1 = hand1[0];
                const point2 = hand2[0];

                const dx = point1.x - point2.x;
                const dy = point1.y - point2.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                // --- 映射逻辑 ---
                const minDistance = 0.1; // 双手合拢时的阈值
                const maxDistance = 0.5; // 双手张开时的阈值
                const minSpread = 0.5; // 最小缩放 (收缩)
                const maxSpread = 2.0; // 最大缩放 (扩散)
                
                let normalized = (distance - minDistance) / (maxDistance - minDistance);
                normalized = Math.max(0, Math.min(1, normalized)); 

                config.spreadFactor = minSpread + normalized * (maxSpread - minSpread);

            } else {
                // 如果手势消失，粒子缓慢恢复到默认大小 (1.0)
                const recoverySpeed = 0.01;
                if (config.spreadFactor > 1.0 + recoverySpeed) {
                    config.spreadFactor -= recoverySpeed;
                } else if (config.spreadFactor < 1.0 - recoverySpeed) {
                     config.spreadFactor += recoverySpeed;
                } else {
                    config.spreadFactor = 1.0;
                }
            }
            
            // 实时更新 Three.js 粒子位置
            updateParticlePositions();
        }

        function startHandTracking() {
            // 确保浏览器支持摄像头
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                console.error("此浏览器不支持访问摄像头。");
                return;
            }
            
            const cameraHelper = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: 640,
                height: 480
            });
            cameraHelper.start();
        }


        // -----------------------------------------------------------------------
        // 5. 辅助和控制函数
        // -----------------------------------------------------------------------

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function initGUI() {
            const gui = new dat.GUI();
            
            // 形状选择器
            gui.add(config, 'model', ['heart', 'star', 'fireworks']) 
               .name('模型选择')
               .onChange(value => {
                   config.model = value;
                   createParticles(models[value]);
               });

            // 颜色选择器
            gui.addColor(config, 'particleColor')
               .name('粒子颜色')
               .onChange(value => {
                   if (particles) {
                       particles.material.color.set(value);
                   }
               });
            
            // 旋转速度控制
            gui.add(config, 'rotationSpeed', 0, 0.05).step(0.001).name('旋转速度');
            
            // 调试用途：显示当前缩放因子 (listen() 使其实时显示变化)
            gui.add(config, 'spreadFactor', 0.5, 2.0).name('缩放因子').listen();
        }

        function initFullScreen() {
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                if (document.documentElement.requestFullscreen) {
                    document.documentElement.requestFullscreen();
                } else if (document.documentElement.webkitRequestFullscreen) {
                    document.documentElement.webkitRequestFullscreen();
                } else if (document.documentElement.msRequestFullscreen) {
                    document.documentElement.msRequestFullscreen();
                }
            });
        }

        function animate() {
            animationFrameId = requestAnimationFrame(animate);

            if (particles) {
                particles.rotation.y += config.rotationSpeed;
            }

            renderer.render(scene, camera);
        }

        // 启动应用
        init();
        animate();
    </script>
</body>
</html>
